<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>節奏王</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; }
    body { margin: 18px; line-height: 1.45; }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .pill { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; }
    .muted { color: #666; }
    .box { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px 14px; }
    #status { font-weight: 700; }
    #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    #score { overflow-x: auto; }
    .warn { color: #b45309; }
    .ok { color: #15803d; }
  </style>
</head>
<body>
  <h1 style="margin: 0 0 10px;">節奏王5</h1>

  <div class="box">
    <div class="row">
      <button id="btnStart">開始錄入</button>
      <button id="btnStop" disabled>Space 結束 / 停止</button>
      <button id="btnReset">重置</button>
      <span class="pill">狀態：<span id="status" class="muted">待機</span></span>
      <span class="pill">音符數：<span id="noteCount">0</span>/100</span>
      <span class="pill">防連點：<span id="debounce">50</span>ms</span>
    </div>

    <p style="margin: 10px 0 0;" class="muted">
      操作：按「開始錄入」後，鍵盤任意鍵敲出節奏；按 <b>Space</b> 結束。<br>
      量化：自動估計最貼近的基本時值（以 <b>16 分音符</b>為最小單位），並輸出接近正式五線譜的節奏記譜（單一音高代表節奏）。
    </p>
  </div>

  <div class="row" style="margin-top: 12px;">
    <span class="pill">推估基本單位：<b id="unitMs">—</b> ms（≈16分）</span>
    <span class="pill">推估速度：<b id="bpm">—</b> BPM（♩=）</span>
    <span class="pill">誤差指標：<b id="fit">—</b></span>
  </div>

  <div class="box" style="margin-top: 12px;">
    <div id="score"></div>
  </div>

  <div class="box" style="margin-top: 12px;">
    <div class="row" style="justify-content: space-between;">
      <b>Debug / 量化結果</b>
      <span class="muted">（顯示每段間隔、量化後以 16分為單位）</span>
    </div>
    <div id="log" style="margin-top: 8px;"></div>
  </div>

  <!-- VexFlow -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@5.0.0/build/vexflow.js"></script>
  <script>
    // 把你原本 window.VF_ 的來源改成 Vex.Flow
    window.VF_ = Vex.Flow;
  </script>

  <script>
    // ======== 錄入與資料 ========
    const MAX_NOTES = 100;
    const DEBOUNCE_MS = 50;

    let isRecording = false;
    let times = [];     // keydown timestamps (ms)
    let intervals = []; // IOI in ms between key presses
    let lastKeyTime = -1;

    const $ = (id) => document.getElementById(id);

    function setStatus(text, cls="muted") {
      const el = $("status");
      el.textContent = text;
      el.className = cls;
    }

    function renderEmptyScore(msg="尚未輸入節奏。") {
      const el = $("score");
      el.innerHTML = "";
      const p = document.createElement("div");
      p.className = "muted";
      p.textContent = msg;
      el.appendChild(p);
    }

    function resetAll() {
      isRecording = false;
      times = [];
      intervals = [];
      lastKeyTime = -1;
      $("noteCount").textContent = "0";
      $("unitMs").textContent = "—";
      $("bpm").textContent = "—";
      $("fit").textContent = "—";
      $("log").textContent = "";
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
      setStatus("待機", "muted");
      renderEmptyScore();
    }

    function startRecording() {
      // 不要 resetAll() 因為會把畫面清掉又變成「尚未輸入」；
      // 但我們確實要清資料
      isRecording = true;
      times = [];
      intervals = [];
      lastKeyTime = -1;

      $("noteCount").textContent = "0";
      $("btnStart").disabled = true;
      $("btnStop").disabled = false;
      setStatus("錄入中（Space 結束）", "ok");
      renderEmptyScore("錄入中…（按 Space 結束）");
    }

    function stopRecording() {
      if (!isRecording) return;
      isRecording = false;

      $("btnStart").disabled = false;
      $("btnStop").disabled = true;

      if (times.length < 2) {
        setStatus("已停止（資料不足）", "warn");
        renderEmptyScore("資料不足：至少要敲兩次鍵才能分析間隔。");
        return;
      }

      intervals = [];
      for (let i=1; i<times.length; i++) intervals.push(times[i] - times[i-1]);
      
      console.log("STOP, times:", times.length, "intervals:", intervals);
      
      analyzeAndRender(intervals);
      setStatus("已輸出五線譜", "ok");
    }

    document.addEventListener("keydown", (e) => {
      if (!isRecording) return;
    
      // 不在 keydown 處理 Space（避免重複觸發/被吃掉）
      if (e.code === "Space") {
        e.preventDefault();
        return;
      }
    
      const now = performance.now();
      if (lastKeyTime >= 0 && (now - lastKeyTime) < DEBOUNCE_MS) return;
      lastKeyTime = now;
    
      if (times.length >= MAX_NOTES) {
        stopRecording();
        return;
      }
    
      times.push(now);
      $("noteCount").textContent = String(times.length);
    });
    
    // 用 keyup 來結束
    document.addEventListener("keyup", (e) => {
      if (!isRecording) return;
      if (e.code === "Space") {
        e.preventDefault();
        stopRecording();
      }
    });

    $("btnStart").addEventListener("click", startRecording);
    $("btnStop").addEventListener("click", stopRecording);
    $("btnReset").addEventListener("click", resetAll);
    $("debounce").textContent = String(DEBOUNCE_MS);

    // ======== 分析：估計基本單位(≈16分)並量化 ========
    function estimateUnitMs(intervals) {
      const minItv = Math.min(...intervals);
      const start = Math.max(40, Math.floor(0.5 * minItv));
      const end   = Math.max(start+1, Math.floor(2.2 * minItv));

      let best = { unit: Math.round(minItv), score: Infinity };

      for (let u = start; u <= end; u++) {
        let err = 0;
        for (const x of intervals) {
          const k = Math.max(1, Math.round(x / u));
          const q = k * u;
          err += Math.abs(x - q);
        }
        const score = err / (u * intervals.length);
        if (score < best.score) best = { unit: u, score };
      }
      return best;
    }

    function quantizeIntervalsTo16th(intervals, unitMs) {
      return intervals.map(x => Math.max(1, Math.round(x / unitMs)));
    }

    // ======== 記譜：將 16分單位數轉成音符/休止 ========
    const UNITS_PER_BAR = 16;

    function splitUnitsToDurations(units, isRest=false) {
      const options = [
        {units: 16, dur: "w",  dots: 0},
        {units: 12, dur: "h",  dots: 1},
        {units: 8,  dur: "h",  dots: 0},
        {units: 6,  dur: "q",  dots: 1},
        {units: 4,  dur: "q",  dots: 0},
        {units: 3,  dur: "8",  dots: 1},
        {units: 2,  dur: "8",  dots: 0},
        {units: 1,  dur: "16", dots: 0},
      ];

      const out = [];
      let remain = units;
      while (remain > 0) {
        const pick = options.find(o => o.units <= remain) || options[options.length-1];
        out.push({ ...pick, isRest });
        remain -= pick.units;
      }
      return out;
    }

    function buildMeasuresFromQuantized(qUnits) {
      const measures = [];
      let cur = [];
      let used = 0;

      function push(token) {
        cur.push(token);
        used += token.units;
        if (used === UNITS_PER_BAR) {
          measures.push(cur);
          cur = [];
          used = 0;
        }
      }

      for (let i=0; i<qUnits.length; i++) {
        let u = qUnits[i];
        while (u > 0) {
          const space = UNITS_PER_BAR - used;
          const take = Math.min(space, u);

          const parts = splitUnitsToDurations(take, false);
          parts.forEach(push);

          u -= take;
        }
      }

      // 補滿最後小節
      if (used !== 0) {
        const restUnits = UNITS_PER_BAR - used;
        splitUnitsToDurations(restUnits, true).forEach(push);
      }

      return measures;
    }

    function analyzeAndRender(intervals) {
      // 等 VexFlow module 把 VF_ 掛好（避免極少數載入競速）
      if (!window.VF_) {
        setTimeout(() => analyzeAndRender(intervals), 50);
        return;
      }

      const est = estimateUnitMs(intervals);
      const unitMs = est.unit;
      const score = est.score;

      const q = quantizeIntervalsTo16th(intervals, unitMs);
      const bpm = 60000 / (unitMs * 4);

      $("unitMs").textContent = String(unitMs);
      $("bpm").textContent = String(Math.round(bpm));
      $("fit").textContent = score.toFixed(4);

      const rawLine = intervals.map(x=>x.toFixed(1)).join(", ");
      const qLine = q.join(", ");
      $("log").textContent =
        `raw intervals (ms):\n${rawLine}\n\nquantized (16th units):\n${qLine}\n\nbars: 4/4, 16 units per bar`;

      const measures = buildMeasuresFromQuantized(q);
      try {
        renderWithVexFlow(measures, Math.round(bpm));
      } catch (err) {
        console.error("renderWithVexFlow failed:", err);
        setStatus("繪譜失敗（請看 Console）", "warn");
        renderEmptyScore("繪譜失敗：請開啟 Console 查看錯誤訊息。");
      }
    }

    // ======== VexFlow 繪製（使用 window.VF_） ========
    function renderWithVexFlow(measures, bpm) {
      const { Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot, Flow } = window.VF_;
      const container = document.getElementById("score");
      container.innerHTML = "";
    
      const margin = 18;
      const lineStaffHeight = 170;
      const maxWidth = Math.max(950, Math.min(1500, container.clientWidth || 1100));
    
      const all = measures.map(tokens => {
        const vexNotes = tokens.map(t => {
          const dur = t.dur + (t.isRest ? "r" : "");
          const n = new StaveNote({ clef: "treble", keys: ["c/5"], duration: dur });
          if (t.dots) Dot.buildAndAttach([n], { all: true });
          return n;
        });
        return { vexNotes };
      });
    
      function measureWidthFor(vexNotes) {
        const n = vexNotes.length;
        return Math.max(180, Math.min(340, 120 + n * 22));
      }
    
      const lines = [];
      let curLine = [];
      let curW = margin;
    
      for (let i = 0; i < all.length; i++) {
        const w = measureWidthFor(all[i].vexNotes);
        if (curLine.length > 0 && curW + w > maxWidth - margin) {
          lines.push(curLine);
          curLine = [];
          curW = margin;
        }
        curLine.push({ idx: i, w });
        curW += w;
      }
      if (curLine.length) lines.push(curLine);
    
      const totalH = lines.length * lineStaffHeight + margin * 2;
      const renderer = new Renderer(container, Renderer.Backends.SVG);
      renderer.resize(maxWidth, totalH);
      const ctx = renderer.getContext();
    
      const BEAT_TICKS = Flow.RESOLUTION / 4; // 4096
      // const BAR_TICKS  = Flow.RESOLUTION;     // 16384（你目前沒用到可先刪）
    
      function isBeamable(note) {
        const d = note.getDuration();
        if (note.isRest && note.isRest()) return false;
        return (d === "8" || d === "16" || d === "32");
      }
    
      function buildBeamsByBeat(vexNotes) {
        const beams = [];
        let beatPos = 0;
        let group = [];
    
        function flushGroup() {
          if (group.length >= 2) beams.push(new Beam(group));
          group = [];
        }
    
        for (const n of vexNotes) {
          const ticks = n.getTicks().value();
    
          if (beatPos > 0 && beatPos + ticks > BEAT_TICKS) {
            flushGroup();
            beatPos = 0;
          }
    
          if (!isBeamable(n)) {
            flushGroup();
          } else {
            group.push(n);
          }
    
          beatPos += ticks;
    
          if (beatPos === BEAT_TICKS) {
            flushGroup();
            beatPos = 0;
          }
        }
    
        flushGroup();
        return beams;
      }
    
      let y = margin;
    
      for (let li = 0; li < lines.length; li++) {
        const line = lines[li];
        let x = margin;
    
        for (let mi = 0; mi < line.length; mi++) {
          const { idx, w } = line[mi];
          const vexNotes = all[idx].vexNotes;
    
          const stave = new Stave(x, y, w);
          if (li === 0 && mi === 0) {
            stave.addClef("treble").addTimeSignature("4/4");
            stave.setText(`♩ = ${bpm}`, 1, { shift_y: -10, shift_x: 10 });
          }
          stave.setContext(ctx).draw();
    
          const voice = new Voice({ num_beats: 4, beat_value: 4 });
          voice.setMode(Voice.Mode.SOFT);
          voice.addTickables(vexNotes);
    
          new Formatter().joinVoices([voice]).format([voice], w - 30);
    
          voice.draw(ctx, stave);
    
          const beams = buildBeamsByBeat(vexNotes);
          beams.forEach(b => b.setContext(ctx).draw());
    
          x += w;
        }
    
        y += lineStaffHeight;
      }
    }

    // 初始
    resetAll();
  </script>
</body>
</html>
