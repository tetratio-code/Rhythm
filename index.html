<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>ç¯€å¥ç‹ v2.9</title>
  <style>
    :root { font-family: system-ui, sans-serif; }
    body { margin: 18px; line-height: 1.45; background-color: #f0f2f5; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 15px; background: white; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    button { padding: 10px 18px; cursor: pointer; border-radius: 6px; border: 1px solid #bbb; font-weight: bold; transition: 0.2s; }
    button:hover:not(:disabled) { background: #f0f0f0; border-color: #888; }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    #log { font-family: 'Cascadia Code', 'Consolas', monospace; font-size: 11px; background: #1e1e1e; color: #50fa7b; padding: 12px; border-radius: 8px; height: 140px; overflow-y: auto; line-height: 1.5; }
    #score { overflow-x: auto; background: white; border: 1px solid #ddd; min-height: 200px; padding: 20px; border-radius: 12px; }
    .pill { padding: 6px 12px; border-radius: 999px; background: #e9ecef; font-size: 13px; margin-right: 8px; font-weight: 600; color: #495057; }
    .status-active { color: #d9480f; animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0.5; } }
  </style>
</head>
<body>
  <h1>ç¯€å¥ç‹ v2.9debug</h1>

  <div class="box">
    <button id="btnStart" disabled>å¼•æ“è¼‰å…¥ä¸­...</button>
    <button id="btnStop" disabled>Space çµæŸ</button>
    <button id="btnReset">é‡ç½®ç³»çµ±</button>
    <span class="pill">ç‹€æ…‹ï¼š<b id="statusText">åˆå§‹åŒ–...</b></span>
    <span class="pill">éŸ³ç¬¦ï¼š<b id="noteCount">0</b></span>
    <span class="pill">é€Ÿåº¦ï¼š<b id="bpmText">â€”</b> BPM</span>
  </div>

  <div id="score"></div>

  <div class="box" style="background: #282a36; border: none;">
    <b style="color: #6272a4; font-size: 10px; text-transform: uppercase;">Professional Layout & Beaming Monitor</b>
    <div id="log">ç³»çµ±æ­£åœ¨è¼‰å…¥ VexFlow 5.0 æ ¸å¿ƒ...</div>
  </div>

  <script type="module">
    import * as Vex from "https://unpkg.com/vexflow@5.0.0/build/esm/entry/vexflow.js";
    
    const VF = Vex;
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    
    function sysLog(msg, isError = false) {
      const time = new Date().toLocaleTimeString([], {hour12:false});
      const div = document.createElement("div");
      div.style.color = isError ? "#ff5555" : "#50fa7b";
      div.textContent = `[${time}] ${msg}`;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // å¼•æ“æº–å‚™å°±ç·’
    sysLog("éŸ³æ¨‚å¼•æ“è¼‰å…¥æˆåŠŸã€‚ç›®å‰éŸ³é«˜ï¼šF4ã€‚åˆ†çµ„ï¼šå››åˆ†éŸ³ç¬¦ã€‚");
    $("btnStart").disabled = false;
    $("btnStart").textContent = "é–‹å§‹éŒ„å…¥";
    $("statusText").textContent = "å¾…æ©Ÿ";

    let isRecording = false, times = [], lastKeyTime = -1;
    const MAX_NOTES = 100, DEBOUNCE = 50;

    function getDurations(units, isRest=false) {
      const opts = [{u:16, d:"w"}, {u:12, d:"h", dt:1}, {u:8, d:"h"}, {u:6, d:"q", dt:1}, {u:4, d:"q"}, {u:3, d:"8", dt:1}, {u:2, d:"8"}, {u:1, d:"16"}];
      let res = [], rem = units;
      while (rem > 0) {
        let p = opts.find(o => o.u <= rem) || opts[opts.length-1];
        res.push({ dur: p.d, dots: p.dt || 0, units: p.u, isRest });
        rem -= p.u;
      }
      return res;
    }

    function buildMeasures(qUnits) {
      const measures = [];
      let curMeasure = [], usedInBar = 0;
      qUnits.forEach(u => {
        let rem = u;
        while (rem > 0) {
          let spaceInBeat = 4 - (usedInBar % 4);
          let take = Math.min(rem, spaceInBeat);
          let parts = getDurations(take, false);
          parts.forEach((p, idx) => {
            p.isTie = (idx < parts.length - 1) || (rem > take);
            curMeasure.push(p);
          });
          usedInBar += take; rem -= take;
          if (usedInBar >= 16) { measures.push(curMeasure); curMeasure = []; usedInBar = 0; }
        }
      });
      // è£œæ»¿æœ€å¾Œä¸€å€‹å°ç¯€çš„ä¼‘æ­¢ç¬¦
      if (usedInBar > 0) {
        getDurations(16 - usedInBar, true).forEach(p => curMeasure.push(p));
        measures.push(curMeasure);
      }
      return measures;
    }

    function renderScore(measures, bpm) {
      // è«‹å°‡æ­¤æ®µæ”¾å…¥ renderScore(measures, bpm) å‡½å¼å…§
      console.group("ğŸµ VexFlow æ¸²æŸ“èª¿è©¦è³‡è¨Š");
      console.log("ç•¶å‰ä¼°ç®— BPM:", bpm);
      console.log("å°ç¯€ç¸½æ•¸:", measures.length);
      console.log("åŸå§‹å°ç¯€æ•¸æ“šçµæ§‹ (Measures):", JSON.parse(JSON.stringify(measures)));
      
      measures.forEach((m, i) => {
          console.log(`ç¬¬ ${i+1} å°ç¯€éŸ³ç¬¦æ•¸:`, m.length);
          console.table(m.map(token => ({
              "Vex Duration": token.dur + (token.isRest ? "r" : ""),
              "é™„é»": token.dots,
              "16åˆ†éŸ³ç¬¦å–®ä½": token.units,
              "æ˜¯å¦é€£è­œ (Tie)": token.isTie,
              "æ˜¯å¦ä¼‘æ­¢": token.isRest
          })));
      });
      console.groupEnd();
      try {
        const { Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot, StaveTie, Fraction } = VF;
        const container = $("score"); container.innerHTML = "";
        
        // --- ç·šæ€§æ’ç‰ˆåƒæ•¸ ---
        const TICK_PX = 25; 
        const CONTENT_WIDTH = 16 * TICK_PX; 
        const FIRST_BAR_PADDING = 80; 
        const totalWidth = (measures.length * CONTENT_WIDTH) + FIRST_BAR_PADDING + 100;
        
        const renderer = new Renderer(container, Renderer.Backends.SVG);
        renderer.resize(totalWidth, 200);
        const ctx = renderer.getContext();
        
        let curX = 20; 
        let allTies = [];
        let pendingTieNote = null;

        measures.forEach((measure, idx) => {
          const isFirst = (idx === 0);
          const barWidth = CONTENT_WIDTH + (isFirst ? FIRST_BAR_PADDING : 0);
          const stave = new Stave(curX, 40, barWidth);
          if (isFirst) stave.addClef("treble").addTimeSignature("4/4");
          stave.setContext(ctx).draw();

          const vNotes = measure.map(t => {
            // ä¿®æ”¹ï¼šéŸ³é«˜ F4ï¼Œç¬¦æ¡¿å‘ä¸Š (stem_direction: 1)
            const n = new StaveNote({ 
              clef: "treble", 
              keys: ["f/4"], 
              duration: t.dur + (t.isRest ? "r" : ""),
              stem_direction: 1 
            });
            if (t.dots) Dot.buildAndAttach([n], { all: true });
            t.vfNote = n;
            return n;
          });

          measure.forEach(token => {
            if (pendingTieNote && !token.isRest) {
              // é€£çµç·šåœ¨ä¸‹æ–¹
              allTies.push(new StaveTie({ firstNote: pendingTieNote, lastNote: token.vfNote }));
              pendingTieNote = null;
            }
            if (token.isTie && !token.isRest) pendingTieNote = token.vfNote;
          });

          const voice = new Voice({ num_beats: 4, beat_value: 4 }).setMode(Voice.Mode.SOFT);
          voice.addTickables(vNotes);
          
          // æ ¼å¼åŒ–å°é½Š
          new Formatter().joinVoices([voice]).formatToStave([voice], stave);

          // æ ¸å¿ƒä¿®æ­£ï¼šåŒ…å«æœ€å¾Œä¸€å€‹éŸ³ç¬¦çš„å®Œæ•´åˆ†çµ„è¡Œç‚º
          // å…ˆç”¢ç”Ÿé€£æ§“ï¼ŒVexFlow æœƒè‡ªå‹•æ¨™è¨˜ beamed ç‹€æ…‹ä»¥ç§»é™¤ç¬¦å°¾
          const beams = Beam.generateBeams(vNotes, { 
            groups: [new Fraction(1, 4)] 
          });

          // ç¹ªè£½éŸ³ç¬¦èˆ‡é€£æ§“
          voice.draw(ctx, stave);
          beams.forEach(b => b.setContext(ctx).draw());
          
          curX += stave.getWidth();
        });

        allTies.forEach(t => t.setContext(ctx).draw());
        sysLog(`æˆåŠŸæ¸²æŸ“ã€‚ç·šæ€§æ¯”ä¾‹ï¼š${TICK_PX}px/å–®ä½ã€‚`);
      } catch (e) {
        sysLog("æ¸²æŸ“éŒ¯èª¤: " + e.message, true);
      }
    }

    $("btnStart").onclick = () => {
      isRecording = true; times = []; lastKeyTime = -1;
      $("btnStart").disabled = true; $("btnStop").disabled = false;
      $("statusText").textContent = "éŒ„å…¥ä¸­...";
      $("statusText").className = "status-active";
      sysLog("é–‹å§‹éŒ„å…¥...");
    };

    const stopRecording = () => {
      isRecording = false;
      $("btnStart").disabled = false; $("btnStop").disabled = true;
      $("statusText").className = "";
      if (times.length < 1) return;
      
      const itvs = [];
      for(let i=1; i<times.length; i++) itvs.push(times[i] - times[i-1]);
      const min = itvs.length > 0 ? Math.min(...itvs) : 250; 
      let bestU = min, bestS = Infinity;
      for (let u = Math.max(40, min*0.5); u <= min*2.2; u++) {
        let err = itvs.reduce((a, x) => a + Math.abs(x - Math.max(1, Math.round(x/u))*u), 0);
        let s = itvs.length > 0 ? err/u : 0;
        if (s < bestS) { bestS = s; bestU = u; }
      }
      const q = itvs.map(x => Math.max(1, Math.round(x / bestU)));

      // ä¿®æ”¹ï¼šæœ€å¾Œä¸€å€‹éŸ³ç¬¦è£œæ»¿ç•¶ä¸‹ 4 åˆ†éŸ³ç¬¦ç©ºç¼º
      const totalUnits = q.reduce((sum, val) => sum + val, 0);
      const fillUnits = 4 - (totalUnits % 4); 
      q.push(fillUnits);

      const bpm = Math.round(60000 / (bestU * 4));
      $("bpmText").textContent = bpm;
      $("statusText").textContent = "å®Œæˆ";
      renderScore(buildMeasures(q), bpm);
    };

    $("btnStop").onclick = stopRecording;
    $("btnReset").onclick = () => location.reload();

    document.onkeydown = (e) => {
      if (!isRecording) return;
      if (e.code === "Space") { e.preventDefault(); stopRecording(); return; }
      const now = performance.now();
      if (lastKeyTime > 0 && (now - lastKeyTime) < DEBOUNCE) return;
      lastKeyTime = now;
      times.push(now);
      $("noteCount").textContent = times.length;
      sysLog(`åµæ¸¬éŸ³ç¬¦ ${times.length}`);
    };
  </script>
</body>
</html>
