<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>節奏王 v1.2</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; }
    body { margin: 18px; line-height: 1.45; }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .pill { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; }
    .muted { color: #666; }
    .box { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px 14px; }
    #status { font-weight: 700; }
    #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    #score { overflow-x: auto; background: #fff; }
    .warn { color: #b45309; }
    .ok { color: #15803d; }
  </style>
</head>
<body>
  <h1 style="margin: 0 0 10px;">節奏王 v1.2</h1>

  <div class="box">
    <div class="row">
      <button id="btnStart">開始錄入</button>
      <button id="btnStop" disabled>Space 結束 / 停止</button>
      <button id="btnReset">重置</button>
      <span class="pill">狀態：<span id="status" class="muted">待機</span></span>
      <span class="pill">音符數：<span id="noteCount">0</span>/100</span>
      <span class="pill">防連點：<span id="debounce">50</span>ms</span>
    </div>
    <p style="margin: 10px 0 0;" class="muted">
      操作：按「開始錄入」後，敲擊任意鍵錄入節奏；按 <b>Space</b> 結束。系統會自動以四分音符為基準進行分組與連結。
    </p>
  </div>

  <div class="row" style="margin-top: 12px;">
    <span class="pill">推估基本單位：<b id="unitMs">—</b> ms</span>
    <span class="pill">推估速度：<b id="bpm">—</b> BPM</span>
    <span class="pill">誤差指標：<b id="fit">—</b></span>
  </div>

  <div class="box" style="margin-top: 12px;">
    <div id="score"></div>
  </div>

  <div class="box" style="margin-top: 12px;">
    <b>Debug / 量化結果</b>
    <div id="log" style="margin-top: 8px;"></div>
  </div>

  <script type="module">
    import {
      Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot, StaveTie, Fraction
    } from "https://unpkg.com/vexflow@5.0.0/build/esm/entry/vexflow.js";
    window.VF_ = { Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot, StaveTie, Fraction };
  </script>

  <script>
    const MAX_NOTES = 100;
    const DEBOUNCE_MS = 50;
    let isRecording = false, times = [], lastKeyTime = -1;
    const $ = (id) => document.getElementById(id);

    function setStatus(text, cls="muted") { $("status").textContent = text; $("status").className = cls; }
    function renderEmptyScore(msg="尚未輸入節奏。") { $("score").innerHTML = `<div class="muted">${msg}</div>`; }

    function resetAll() {
      isRecording = false; times = []; lastKeyTime = -1;
      $("noteCount").textContent = "0"; $("unitMs").textContent = "—"; $("bpm").textContent = "—";
      $("fit").textContent = "—"; $("log").textContent = "";
      $("btnStart").disabled = false; $("btnStop").disabled = true;
      setStatus("待機"); renderEmptyScore();
    }

    function startRecording() {
      isRecording = true; times = []; lastKeyTime = -1;
      $("noteCount").textContent = "0"; $("btnStart").disabled = true; $("btnStop").disabled = false;
      setStatus("錄入中", "ok"); renderEmptyScore("錄入中…（Space 結束）");
    }

    function stopRecording() {
      if (!isRecording || times.length < 2) { resetAll(); return; }
      isRecording = false; $("btnStart").disabled = false; $("btnStop").disabled = true;
      let intervals = [];
      for (let i=1; i<times.length; i++) intervals.push(times[i] - times[i-1]);
      analyzeAndRender(intervals);
      setStatus("已輸出五線譜", "ok");
    }

    document.addEventListener("keydown", (e) => {
      if (!isRecording) return;
      if (e.code === "Space") { e.preventDefault(); stopRecording(); return; }
      const now = performance.now();
      if (lastKeyTime >= 0 && (now - lastKeyTime) < DEBOUNCE_MS) return;
      lastKeyTime = now;
      if (times.length < MAX_NOTES) { times.push(now); $("noteCount").textContent = times.length; }
    });

    $("btnStart").onclick = startRecording;
    $("btnStop").onclick = stopRecording;
    $("btnReset").onclick = resetAll;

    function estimateUnitMs(intervals) {
      const minItv = Math.min(...intervals);
      let best = { unit: Math.round(minItv), score: Infinity };
      for (let u = Math.max(40, minItv*0.5); u <= minItv*2.2; u++) {
        let err = 0;
        intervals.forEach(x => { err += Math.abs(x - Math.max(1, Math.round(x/u))*u); });
        let s = err / (u * intervals.length);
        if (s < best.score) best = { unit: u, score: s };
      }
      return best;
    }

    function splitUnitsToDurations(units, isRest=false) {
      const opt = [
        {u:16, d:"w", dt:0}, {u:12, d:"h", dt:1}, {u:8, d:"h", dt:0},
        {u:6, d:"q", dt:1}, {u:4, d:"q", dt:0}, {u:3, d:"8", dt:1},
        {u:2, d:"8", dt:0}, {u:1, d:"16", dt:0}
      ];
      let res = [], rem = units;
      while (rem > 0) {
        let p = opt.find(o => o.u <= rem) || opt[opt.length-1];
        res.push({ dur: p.d, dots: p.dt, units: p.u, isRest });
        rem -= p.u;
      }
      return res;
    }

    function buildMeasuresFromQuantized(qUnits) {
      const measures = [];
      let cur = [], usedInBar = 0;
      qUnits.forEach(u => {
        let rem = u;
        while (rem > 0) {
          let spaceInBeat = 4 - (usedInBar % 4);
          let take = Math.min(rem, spaceInBeat);
          let parts
