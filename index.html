<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>節奏王</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; }
    body { margin: 18px; line-height: 1.45; }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .pill { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; }
    .muted { color: #666; }
    .box { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px 14px; }
    #status { font-weight: 700; }
    #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    #score { overflow-x: auto; }
    .warn { color: #b45309; }
    .ok { color: #15803d; }
  </style>
</head>
<body>
  <h1 style="margin: 0 0 10px;">節奏王</h1>

  <div class="box">
    <div class="row">
      <button id="btnStart">開始錄入</button>
      <button id="btnStop" disabled>Space 結束 / 停止</button>
      <button id="btnReset">重置</button>
      <span class="pill">狀態：<span id="status" class="muted">待機</span></span>
      <span class="pill">音符數：<span id="noteCount">0</span>/100</span>
      <span class="pill">防連點：<span id="debounce">50</span>ms</span>
    </div>

    <p style="margin: 10px 0 0;" class="muted">
      操作：按「開始錄入」後，鍵盤任意鍵敲出節奏；按 <b>Space</b> 結束。<br>
      量化：自動估計最貼近的基本時值（以 <b>16 分音符</b>為最小單位），並輸出接近正式五線譜的節奏記譜（單一音高代表節奏）。
    </p>
  </div>

  <div class="row" style="margin-top: 12px;">
    <span class="pill">推估基本單位：<b id="unitMs">—</b> ms（≈16分）</span>
    <span class="pill">推估速度：<b id="bpm">—</b> BPM（♩=）</span>
    <span class="pill">誤差指標：<b id="fit">—</b></span>
  </div>

  <div class="box" style="margin-top: 12px;">
    <div id="score"></div>
  </div>

  <div class="box" style="margin-top: 12px;">
    <div class="row" style="justify-content: space-between;">
      <b>Debug / 量化結果</b>
      <span class="muted">（顯示每段間隔、量化後以 16分為單位）</span>
    </div>
    <div id="log" style="margin-top: 8px;"></div>
  </div>

  <!-- VexFlow (ESM) -->
  <script type="module">
    import {
      Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot
    } from "https://unpkg.com/vexflow@5.0.0/build/esm/entry/vexflow.js";

    // 讓非 module 的主程式可以用
    window.VF_ = { Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot };
  </script>

  <script>
    // ======== 錄入與資料 ========
    const MAX_NOTES = 100;
    const DEBOUNCE_MS = 50;

    let isRecording = false;
    let times = [];     // keydown timestamps (ms)
    let intervals = []; // IOI in ms between key presses
    let lastKeyTime = -1;

    const $ = (id) => document.getElementById(id);

    function setStatus(text, cls="muted") {
      const el = $("status");
      el.textContent = text;
      el.className = cls;
    }

    function renderEmptyScore(msg="尚未輸入節奏。") {
      const el = $("score");
      el.innerHTML = "";
      const p = document.createElement("div");
      p.className = "muted";
      p.textContent = msg;
      el.appendChild(p);
    }

    function resetAll() {
      isRecording = false;
      times = [];
      intervals = [];
      lastKeyTime = -1;
      $("noteCount").textContent = "0";
      $("unitMs").textContent = "—";
      $("bpm").textContent = "—";
      $("fit").textContent = "—";
      $("log").textContent = "";
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
      setStatus("待機", "muted");
      renderEmptyScore();
    }

    function startRecording() {
      // 不要 resetAll() 因為會把畫面清掉又變成「尚未輸入」；
      // 但我們確實要清資料
      isRecording = true;
      times = [];
      intervals = [];
      lastKeyTime = -1;

      $("noteCount").textContent = "0";
      $("btnStart").disabled = true;
      $("btnStop").disabled = false;
      setStatus("錄入中（Space 結束）", "ok");
      renderEmptyScore("錄入中…（按 Space 結束）");
    }

    function stopRecording() {
      if (!isRecording) return;
      isRecording = false;

      $("btnStart").disabled = false;
      $("btnStop").disabled = true;

      if (times.length < 2) {
        setStatus("已停止（資料不足）", "warn");
        renderEmptyScore("資料不足：至少要敲兩次鍵才能分析間隔。");
        return;
      }

      intervals = [];
      for (let i=1; i<times.length; i++) intervals.push(times[i] - times[i-1]);

      analyzeAndRender(intervals);
      setStatus("已輸出五線譜", "ok");
    }

    document.addEventListener("keydown", (e) => {
      if (!isRecording) return;

      if (e.code === "Space") {
        e.preventDefault();
        stopRecording();
        return;
      }

      const now = performance.now();
      if (lastKeyTime >= 0 && (now - lastKeyTime) < DEBOUNCE_MS) return;
      lastKeyTime = now;

      if (times.length >= MAX_NOTES) {
        stopRecording();
        return;
      }

      times.push(now);
      $("noteCount").textContent = String(times.length);
    });

    $("btnStart").addEventListener("click", startRecording);
    $("btnStop").addEventListener("click", stopRecording);
    $("btnReset").addEventListener("click", resetAll);
    $("debounce").textContent = String(DEBOUNCE_MS);

    // ======== 分析：估計基本單位(≈16分)並量化 ========
    function estimateUnitMs(intervals) {
      const minItv = Math.min(...intervals);
      const start = Math.max(40, Math.floor(0.5 * minItv));
      const end   = Math.max(start+1, Math.floor(2.2 * minItv));

      let best = { unit: Math.round(minItv), score: Infinity };

      for (let u = start; u <= end; u++) {
        let err = 0;
        for (const x of intervals) {
          const k = Math.max(1, Math.round(x / u));
          const q = k * u;
          err += Math.abs(x - q);
        }
        const score = err / (u * intervals.length);
        if (score < best.score) best = { unit: u, score };
      }
      return best;
    }

    function quantizeIntervalsTo16th(intervals, unitMs) {
      return intervals.map(x => Math.max(1, Math.round(x / unitMs)));
    }

    // ======== 記譜：將 16分單位數轉成音符/休止 ========
    const UNITS_PER_BAR = 16;

    function splitUnitsToDurations(units, isRest=false) {
      const options = [
        {units: 16, dur: "w",  dots: 0},
        {units: 12, dur: "h",  dots: 1},
        {units: 8,  dur: "h",  dots: 0},
        {units: 6,  dur: "q",  dots: 1},
        {units: 4,  dur: "q",  dots: 0},
        {units: 3,  dur: "8",  dots: 1},
        {units: 2,  dur: "8",  dots: 0},
        {units: 1,  dur: "16", dots: 0},
      ];

      const out = [];
      let remain = units;
      while (remain > 0) {
        const pick = options.find(o => o.units <= remain) || options[options.length-1];
        out.push({ ...pick, isRest });
        remain -= pick.units;
      }
      return out;
    }

    function buildMeasuresFromQuantized(qUnits) {
      const measures = [];
      let cur = [];
      let used = 0;

      function push(token) {
        cur.push(token);
        used += token.units;
        if (used === UNITS_PER_BAR) {
          measures.push(cur);
          cur = [];
          used = 0;
        }
      }

      for (let i=0; i<qUnits.length; i++) {
        let u = qUnits[i];
        while (u > 0) {
          const space = UNITS_PER_BAR - used;
          const take = Math.min(space, u);

          const parts = splitUnitsToDurations(take, false);
          parts.forEach(push);

          u -= take;
        }
      }

      // 補滿最後小節
      if (used !== 0) {
        const restUnits = UNITS_PER_BAR - used;
        splitUnitsToDurations(restUnits, true).forEach(push);
      }

      return measures;
    }

    function analyzeAndRender(intervals) {
      // 等 VexFlow module 把 VF_ 掛好（避免極少數載入競速）
      if (!window.VF_) {
        setTimeout(() => analyzeAndRender(intervals), 50);
        return;
      }

      const est = estimateUnitMs(intervals);
      const unitMs = est.unit;
      const score = est.score;

      const q = quantizeIntervalsTo16th(intervals, unitMs);
      const bpm = 60000 / (unitMs * 4);

      $("unitMs").textContent = String(unitMs);
      $("bpm").textContent = String(Math.round(bpm));
      $("fit").textContent = score.toFixed(4);

      const rawLine = intervals.map(x=>x.toFixed(1)).join(", ");
      const qLine = q.join(", ");
      $("log").textContent =
        `raw intervals (ms):\n${rawLine}\n\nquantized (16th units):\n${qLine}\n\nbars: 4/4, 16 units per bar`;

      const measures = buildMeasuresFromQuantized(q);
      renderWithVexFlow(measures, Math.round(bpm));
    }

    // ======== VexFlow 繪製（使用 window.VF_） ========
    function renderWithVexFlow(measures, bpm) {
      const { Renderer, Stave, StaveNote, Voice, Formatter, Beam, Dot } = window.VF_;
      const container = $("score");
      container.innerHTML = "";

      const width = Math.max(900, Math.min(1400, container.clientWidth || 1000));
      const staffHeight = 150;
      const margin = 18;

      const measuresPerLine = width >= 1200 ? 6 : (width >= 1000 ? 5 : 4);
      const totalLines = Math.max(1, Math.ceil(measures.length / measuresPerLine));

      const renderer = new Renderer(container, Renderer.Backends.SVG);
      renderer.resize(width, totalLines * staffHeight + margin * 2);
      const ctx = renderer.getContext();

      let y = margin;

      for (let line = 0; line < totalLines; line++) {
        const start = line * measuresPerLine;
        const end = Math.min(measures.length, start + measuresPerLine);
        const lineMeasures = measures.slice(start, end);

        const staffW = Math.floor((width - margin * 2) / measuresPerLine);
        let x = margin;

        for (let mi = 0; mi < lineMeasures.length; mi++) {
          const tokens = lineMeasures[mi];

          const stave = new Stave(x, y, staffW);
          if (line === 0 && mi === 0) {
            stave.addClef("treble").addTimeSignature("4/4");
            stave.setText(`♩ = ${bpm}`, 1, { shift_y: -10, shift_x: 10 }); // 1=ABOVE
          }
          stave.setContext(ctx).draw();

          const vexNotes = tokens.map(t => {
            const dur = t.dur + (t.isRest ? "r" : "");
            const n = new StaveNote({ clef: "treble", keys: ["c/5"], duration: dur });
            if (t.dots) Dot.buildAndAttach([n], { all: true });
            return n;
          });

          // 讓 8/16 音符自動連線（更像正式譜）
          const beams = Beam.generateBeams(vexNotes, {
            groups: [{ num_beats: 1, beat_value: 4 }] // 4/4 每拍一組
          });

          const voice = new Voice({ num_beats: 4, beat_value: 4 });
          voice.addTickables(vexNotes);

          new Formatter().joinVoices([voice]).format([voice], staffW - 30);

          voice.draw(ctx, stave);
          beams.forEach(b => b.setContext(ctx).draw());

          x += staffW;
        }

        y += staffHeight;
      }
    }

    // 初始
    resetAll();
  </script>
</body>
</html>
